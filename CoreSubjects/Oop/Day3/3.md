Perfect! Letâ€™s dive into **Inheritance in Java** â€” one of the most important pillars of Object-Oriented Programming (OOP).

---

# ğŸ§¬ Inheritance in Java (With Simple Theory + Examples)

---

## âœ… What is Inheritance?

> **Inheritance** is the process where **one class (child/subclass)** inherits the **properties (variables) and behaviors (methods)** of **another class (parent/superclass)**.

âœ… It helps **reuse code** and build a **hierarchy** of classes.

---

## ğŸ”¹ Why Use Inheritance?

1. âœ… **Code Reusability** â€“ Write once, use many times
2. âœ… **Extensibility** â€“ Build on top of existing code
3. âœ… **Organized Structure** â€“ Parent-child relationships are clear
4. âœ… **Polymorphism** â€“ Enables method overriding for flexibility

---

## ğŸ”¸ Syntax

```java
class Parent {
    // parent class members
}

class Child extends Parent {
    // child class inherits from Parent
}
```

ğŸ”¹ `extends` keyword is used to inherit from a class.

---

## ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ Real-World Example

* **Vehicle** (Parent) â†’ has `speed`, `start()`, `stop()`
* **Car** (Child) â†’ inherits everything from Vehicle, and adds `airConditioning` or `musicPlayer`

---

## ğŸ” Simple Code Example

```java
// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // inherited method
        d.bark();  // own method
    }
}
```

### ğŸŸ¢ Output:

```
This animal eats food  
Dog barks
```

---

## ğŸ”„ Types of Inheritance in Java

| Type             | Supported in Java? | Description                                   |
| ---------------- | ------------------ | --------------------------------------------- |
| **Single**       | âœ… Yes              | One child inherits from one parent            |
| **Multilevel**   | âœ… Yes              | Chain of inheritance (A â†’ B â†’ C)              |
| **Hierarchical** | âœ… Yes              | One parent, multiple children                 |
| **Multiple**     | âŒ No (via class)   | Not directly supported (can use interfaces)   |
| **Hybrid**       | âŒ No (via class)   | Not directly supported (interfaces + classes) |

---

### ğŸ”¸ 1. Single Inheritance

```java
class A {
    void show() {
        System.out.println("Hello from A");
    }
}

class B extends A {
    void display() {
        System.out.println("Hello from B");
    }
}
```

---

### ğŸ”¸ 2. Multilevel Inheritance

```java
class A {
    void showA() {
        System.out.println("A");
    }
}

class B extends A {
    void showB() {
        System.out.println("B");
    }
}

class C extends B {
    void showC() {
        System.out.println("C");
    }
}
```

---

### ğŸ”¸ 3. Hierarchical Inheritance

```java
class Parent {
    void greet() {
        System.out.println("Hello");
    }
}

class Son extends Parent {}
class Daughter extends Parent {}
```

---

## ğŸ”§ Method Overriding (Important in Inheritance)

Child class can **override** a parent class method (same name + parameters):

```java
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}
```

---

## ğŸ“¦ `super` Keyword

Used to:

1. Access parent class methods/variables
2. Call parent class constructor

```java
class Animal {
    Animal() {
        System.out.println("Animal Constructor");
    }
}

class Dog extends Animal {
    Dog() {
        super();  // calls parent constructor
        System.out.println("Dog Constructor");
    }
}
```

---

## âš ï¸ Notes

* Java doesnâ€™t support **multiple inheritance** using classes to avoid ambiguity (diamond problem).
* Interfaces can be used for **multiple inheritance**.

---

## ğŸ“Œ Summary

| Concept     | Meaning                            |
| ----------- | ---------------------------------- |
| Inheritance | Getting features from parent class |
| `extends`   | Keyword to implement inheritance   |
| `super`     | Access parent members              |
| Overriding  | Redefining method in child class   |

---

## ğŸ’¡ Real-Life Examples

| Parent Class | Child Class(es)                |
| ------------ | ------------------------------ |
| `Employee`   | `Manager`, `Clerk`, `HR`       |
| `Vehicle`    | `Bike`, `Car`, `Truck`         |
| `Shape`      | `Circle`, `Square`, `Triangle` |

---

Great! Letâ€™s now explore the **`private` keyword in Java** â€” itâ€™s all about **data hiding** and **encapsulation**, which are core parts of OOP.

---

# ğŸ” `private` Keyword in Java (Simplified with Examples)

---

## âœ… What is `private`?

> `private` is an **access modifier** in Java used to **restrict access** to a class member (variable, method, or constructor).

ğŸ”’ If something is marked `private`, it can **only be accessed within the same class**.

---

## ğŸ”‘ Why Use `private`?

* To implement **encapsulation** (data hiding)
* To **protect** variables and logic from being accessed or modified directly
* To **control access** using `getter` and `setter` methods

---

## ğŸ”¸ Where Can You Use `private`?

| Can be applied to | Meaning                                                           |
| ----------------- | ----------------------------------------------------------------- |
| **Variables**     | Only class methods can access it                                  |
| **Methods**       | Cannot be called outside the class                                |
| **Constructors**  | Used in Singleton or Factory patterns to restrict object creation |
| **Inner Classes** | Can be private to restrict scope                                  |

---

## ğŸ” Example â€“ Private Variable

```java
class Student {
    private int age; // ğŸ‘ˆ private variable

    // public method to access private variable
    public void setAge(int a) {
        if (a >= 0) {
            age = a;
        }
    }

    public int getAge() {
        return age;
    }
}

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.setAge(20);
        System.out.println("Age: " + s.getAge());  // âœ… Age: 20
        // s.age = 25;  âŒ Error: age has private access
    }
}
```

### ğŸŸ¢ Output:

```
Age: 20
```

---

## ğŸ”’ Trying to access private directly

```java
class Demo {
    private int num = 10;
}

public class Test {
    public static void main(String[] args) {
        Demo d = new Demo();
        System.out.println(d.num);  // âŒ Error: num has private access
    }
}
```

---

## ğŸ‘¨â€ğŸ« Real-World Analogy

Think of a **Bank ATM Machine**:

* You can **view balance** or **withdraw cash** using buttons (public methods).
* You **cannot access the internal balance variable** or machine logic â€” itâ€™s `private`.

---

## ğŸ“Œ Key Points

| Point                        | Explanation                               |
| ---------------------------- | ----------------------------------------- |
| Scope                        | Only accessible **within the same class** |
| Helps in                     | **Encapsulation** (protecting data)       |
| Access outside class?        | âŒ Not allowed directly                    |
| Access via `getter`/`setter` | âœ… Yes, using public methods               |

---

## ğŸ” Common Pairing

| Access Modifier         | Scope                      |
| ----------------------- | -------------------------- |
| `private`               | Same class                 |
| `default` (no modifier) | Same package               |
| `protected`             | Same package + subclass    |
| `public`                | Accessible from everywhere |

---

## â“Can `private` methods be inherited?

No, **private methods are not inherited** by subclasses and **cannot be overridden**.

---

Great! Let's now understand the **`super` keyword in Java** â€” it's commonly used with **inheritance** to refer to the **parent class**.

---

# ğŸ§­ `super` Keyword in Java â€“ Simplified Notes with Examples

---

## âœ… What is `super`?

The `super` keyword is used to **refer to the immediate parent class** in Java.

It is mainly used for:

1. Accessing **parent class constructor**
2. Accessing **parent class method**
3. Accessing **parent class variable**

---

## ğŸ”¸ When to Use `super`?

* When child and parent classes have the **same method or variable names**, and you want to call the **parent's version**.
* To call the **parent class constructor** explicitly.
* To **avoid code duplication** by reusing parent behavior.

---

## ğŸ”¹ 1. Using `super` to Call Parent Class Method

```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        super.sound(); // ğŸ‘ˆ calling parent method
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
    }
}
```

### âœ… Output:

```
Animal makes a sound
Dog barks
```

---

## ğŸ”¹ 2. Using `super` to Call Parent Class Variable

```java
class Vehicle {
    int speed = 60;
}

class Car extends Vehicle {
    int speed = 100;

    void display() {
        System.out.println("Child speed: " + speed);
        System.out.println("Parent speed: " + super.speed);  // ğŸ‘ˆ accessing parent variable
    }
}
```

### âœ… Output:

```
Child speed: 100
Parent speed: 60
```

---

## ğŸ”¹ 3. Using `super()` to Call Parent Constructor

```java
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Student extends Person {
    Student() {
        super(); // ğŸ‘ˆ calling parent constructor
        System.out.println("Student constructor");
    }
}
```

### âœ… Output:

```
Person constructor
Student constructor
```

---

## âš ï¸ Note:

* If you donâ€™t explicitly write `super()`, Java automatically adds it as the **first line** of the subclass constructor.
* If the parent class does not have a **no-argument constructor**, then **you must** use `super(args...)` with parameters.

---

## ğŸ§  Real-World Analogy

> Think of a subclass as a new version of something old.
> You can still **access old features** using `super`.

For example, a child inherits behavior from a parent. If both have a "speak()" method, the child can still call the parentâ€™s version using `super.speak()`.

---

## ğŸ§¾ Summary Table

| Use Case                | Example Syntax             | Purpose                       |
| ----------------------- | -------------------------- | ----------------------------- |
| Call parent variable    | `super.varName`            | Access hidden field in parent |
| Call parent method      | `super.methodName()`       | Reuse parent behavior         |
| Call parent constructor | `super()` or `super(args)` | Initialize parent constructor |

---

No problem! Let's explain the **`super` keyword** again in a very **simple way** with easy examples. We'll use real-life style and less theory â€” perfect for beginners.

---

## ğŸ”¹ Think Like This:

Imagine your **Father (Parent class)** has a **bike** and you (Child class) also have a **bike**.

But you still want to use your **Father's bike** sometimes.

To use it, you say:
ğŸ‘‰ "**super.bike** â€” I want to use *Father's* bike."

That's how Java works too.
You use `super` when you want to use **something from the parent class** â€” like:

* **Variable**
* **Method**
* **Constructor**

---

## âœ… Example 1: `super` with Variable

```java
class Father {
    int money = 1000;
}

class Son extends Father {
    int money = 500;

    void showMoney() {
        System.out.println("Son's Money: " + money);
        System.out.println("Father's Money: " + super.money);  // Using super to access father's money
    }
}

public class Main {
    public static void main(String[] args) {
        Son s = new Son();
        s.showMoney();
    }
}
```

### ğŸ“Œ Output:

```
Son's Money: 500
Father's Money: 1000
```

ğŸ‘‰ Here, **`super.money`** means "use Father's version of money".

---

## âœ… Example 2: `super` with Method

```java
class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    void sound() {
        super.sound();  // Use parent's sound method
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
    }
}
```

### ğŸ“Œ Output:

```
Animal sound
Dog barks
```

ğŸ‘‰ Even though Dog has its own `sound()` method, we first called **Animal's method** using `super.sound()`.

---

## âœ… Example 3: `super()` with Constructor

```java
class Person {
    Person() {
        System.out.println("Person is created");
    }
}

class Student extends Person {
    Student() {
        super();  // Call Person's constructor
        System.out.println("Student is created");
    }
}

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
    }
}
```

### ğŸ“Œ Output:

```
Person is created
Student is created
```

ğŸ‘‰ The `super()` line automatically calls the **parent constructor** before doing the studentâ€™s work.

---

## ğŸ¯ Summary (in Easy Words)

| Use              | What it Means             | Example         |
| ---------------- | ------------------------- | --------------- |
| `super.variable` | Use parent's variable     | `super.money`   |
| `super.method()` | Use parent's method       | `super.sound()` |
| `super()`        | Call parent's constructor | `super()`       |

---

Sure! Letâ€™s break down **Single Inheritance** in Java in very simple English with a **real-life example**, **code**, and **output**.

---

## ğŸ”¹ What is Single Inheritance?

**Single Inheritance** means:

> One class inherits (extends) from only **one parent class**.

It's like a **child inherits features from one parent**.

---

### âœ… Real-Life Example:

* **Parent**: Father
* **Child**: Son

The Son inherits the properties or behavior from Father â€” like surname, habits, etc.

---

### âœ… Java Code Example:

```java
// Parent class
class Father {
    void display() {
        System.out.println("I am the Father.");
    }
}

// Child class (inherits Father)
class Son extends Father {
    void show() {
        System.out.println("I am the Son.");
    }
}

// Main class to run the code
public class Main {
    public static void main(String[] args) {
        Son s1 = new Son();

        s1.display();  // From Father class
        s1.show();     // From Son class
    }
}
```

---

### ğŸ“Œ Output:

```
I am the Father.
I am the Son.
```

---

### âœ… Diagram to Understand (Text form):

```
Father class
   â†‘
   |
Son class
```

* `Son` **extends** `Father`
* `Son` can use both `show()` and `display()` methods
* But `Father` can't use `show()` (because parent doesn't inherit from child)

---

## ğŸ¯ Summary:

| Term               | Meaning                                   |
| ------------------ | ----------------------------------------- |
| Parent Class       | The class being inherited from (`Father`) |
| Child Class        | The class that inherits (`Son`)           |
| `extends`          | Keyword used for inheritance              |
| Single Inheritance | Only one parent class is inherited        |

---

Great! Let's now understand **Multiple Inheritance** in Java â€” in **easy English** with **real-world logic**, **Java syntax**, and **example**.

---

## ğŸ”¹ What is Multiple Inheritance?

**Multiple Inheritance** means:

> A class **inherits from more than one class**.

---

### âŒ Java Does **NOT** Support Multiple Inheritance With Classes

Java does **not** allow a class to inherit from **more than one class directly** using `extends`.

This is because:

> It causes **ambiguity** (confusion) when two parent classes have the **same method name**.

---

### âœ… So, How to Do Multiple Inheritance in Java?

Java supports **multiple inheritance through interfaces** (not classes).

---

### âœ… Real-Life Example:

* Suppose you have:

  * `Camera` â†’ takes photos
  * `Phone` â†’ makes calls
* You want to make a **SmartPhone** that does **both**.

This is possible using interfaces.

---

## âœ… Java Code Example:

```java
// Interface 1
interface Camera {
    void takePhoto();
}

// Interface 2
interface Phone {
    void makeCall();
}

// Class implementing both interfaces
class SmartPhone implements Camera, Phone {
    public void takePhoto() {
        System.out.println("Taking a photo...");
    }

    public void makeCall() {
        System.out.println("Making a call...");
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        SmartPhone sp = new SmartPhone();
        sp.takePhoto();  // from Camera
        sp.makeCall();   // from Phone
    }
}
```

---

### ğŸ“Œ Output:

```
Taking a photo...
Making a call...
```

---

## ğŸ§  Why Interfaces?

Interfaces solve the **diamond problem** (method conflict from two parent classes).
Each interface is like a **contract** the child class agrees to follow.

---

## ğŸ¯ Summary:

| Concept                  | Inheritance Type        | Java Supports? | How to do it?           |
| ------------------------ | ----------------------- | -------------- | ----------------------- |
| **Single Inheritance**   | One parent class        | âœ… Yes          | Using `extends`         |
| **Multiple Inheritance** | Multiple parent classes | âŒ No           | âœ… Only via `interfaces` |

---

Great! Let's understand **Hierarchical Inheritance** in Java in **simple English** with **example and real-life logic**.

---

## ğŸ”· What is Hierarchical Inheritance?

> When **multiple classes inherit from the same parent class**, it's called **Hierarchical Inheritance**.

---

### âœ… Real-Life Example:

Think of a **base class** called `Animal`.

Now suppose:

* `Dog` is an animal ğŸ¶
* `Cat` is an animal ğŸ±
* `Horse` is an animal ğŸ´

All these classes (`Dog`, `Cat`, `Horse`) **inherit** from one common parent: `Animal`.

Thatâ€™s **hierarchical inheritance**.

---

### âœ… Diagram:

```
         Animal
         /  |  \
     Dog  Cat Horse
```

---

## âœ… Java Code Example:

```java
// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class 1
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks.");
    }
}

// Child class 2
class Cat extends Animal {
    void meow() {
        System.out.println("Cat meows.");
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // from Animal
        d.bark();  // from Dog

        Cat c = new Cat();
        c.eat();   // from Animal
        c.meow();  // from Cat
    }
}
```

---

### âœ… Output:

```
This animal eats food.
Dog barks.
This animal eats food.
Cat meows.
```

---

## ğŸ§  Key Points:

* One **base class** â†’ `Animal`
* Multiple **derived classes** â†’ `Dog`, `Cat`, `Horse`
* All child classes can use **common methods** of parent (like `eat()`)

---

## ğŸ¯ Summary:

| Term                         | Meaning                                                             |
| ---------------------------- | ------------------------------------------------------------------- |
| **Hierarchical Inheritance** | Many child classes inherit from a single parent class               |
| **Use case**                 | When multiple things share common behavior but also have uniqueness |

---

## ğŸ”· What is Hybrid Inheritance in Java?

> **Hybrid Inheritance** means **combining two or more types of inheritance** (like single, multilevel, hierarchical, etc.).

But âŒ **Java does not support hybrid inheritance using classes alone** because it can lead to **ambiguity** (like the Diamond Problem).
âœ… Instead, Java supports **hybrid inheritance** using **interfaces** to safely avoid that problem.

---

## âœ… Simple Explanation:

Imagine this combination:

* **Class A** is the base.
* **Class B and Class C** extend A (Hierarchical Inheritance).
* **Class D** extends both B and C. (This would create **Multiple Inheritance**, which Java doesn't allow with classes.)

So we **use interfaces** to allow D to inherit from B and C **without conflict**.

---

### âš ï¸ Problem with Classes:

```java
class A {
    void display() {
        System.out.println("Hello from A");
    }
}

class B extends A { }

class C extends A { }

// âŒ Java will NOT allow this
class D extends B, C { } // Error: Java doesn't support multiple inheritance with classes
```

---

### âœ… Correct Approach Using Interfaces:

```java
interface A {
    void show();
}

interface B extends A {
    void displayB();
}

interface C extends A {
    void displayC();
}

// D implements B and C (Hybrid Inheritance using interfaces)
class D implements B, C {
    public void show() {
        System.out.println("Hello from A");
    }

    public void displayB() {
        System.out.println("Hello from B");
    }

    public void displayC() {
        System.out.println("Hello from C");
    }
}

public class Main {
    public static void main(String[] args) {
        D obj = new D();
        obj.show();       // from A
        obj.displayB();   // from B
        obj.displayC();   // from C
    }
}
```

---

### âœ… Output:

```
Hello from A
Hello from B
Hello from C
```

---

## âœ… Real-World Example:

Letâ€™s say:

* `Vehicle` interface: has method `start()`
* `Electric` interface: has method `charge()`
* `Car` class implements both

This is **Hybrid** because it combines **multiple inheritance** (via interfaces) and **single inheritance** (Car is one class).

---

### âœ… Summary:

| Term                   | Meaning                                         |
| ---------------------- | ----------------------------------------------- |
| **Hybrid Inheritance** | Combination of two or more types of inheritance |
| **Supported in Java?** | âŒ Not with classes only, âœ… Yes with interfaces  |
| **Avoids issues like** | Diamond Problem                                 |
| **How to implement**   | Use interfaces + classes                        |

---

Let's understand **Polymorphism** in Java in a **very simple way**, with **real-world examples**, **types**, and **code examples**. ğŸ§ ğŸ’¡

---

## ğŸ”· What is Polymorphism?

**Polymorphism** means:

> "**One thing, many forms**"

In Java:

* A single **function**, **method**, or **object** behaves **differently** based on the **context**.

---

### âœ… Real-World Example:

Imagine a person named **Aniket**:

* At **college**, he's a **student**
* At **home**, he's a **son**
* On the **football ground**, he's a **player**

ğŸ§â€â™‚ï¸ Aniket = 1 person
ğŸ­ Different **roles** = Different **behaviors**

This is **Polymorphism**.

---

## ğŸ”· Types of Polymorphism in Java

| Type             | Also Called As         | How it's Achieved                      |
| ---------------- | ---------------------- | -------------------------------------- |
| **Compile-Time** | **Method Overloading** | Same method name, different parameters |
| **Runtime**      | **Method Overriding**  | Same method in parent and child class  |

---

## âœ… 1. Compile-Time Polymorphism (Method Overloading)

Same method name, but different number or type of arguments.

```java
class MathOperations {
    void add(int a, int b) {
        System.out.println(a + b);
    }

    void add(double a, double b) {
        System.out.println(a + b);
    }
}

public class Main {
    public static void main(String[] args) {
        MathOperations obj = new MathOperations();
        obj.add(2, 3);        // Calls int version
        obj.add(2.5, 3.5);    // Calls double version
    }
}
```

### âœ… Output:

```
5
6.0
```

âœ… *This is decided at compile time â€” hence called compile-time polymorphism.*

---

## âœ… 2. Runtime Polymorphism (Method Overriding)

Subclass **overrides** the parent class method.

```java
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal obj = new Dog(); // Parent class reference, child class object
        obj.sound();            // Calls Dog's sound()
    }
}
```

### âœ… Output:

```
Dog barks
```

âœ… *Which method gets called is decided at runtime â€” hence called runtime polymorphism.*

---

## ğŸ”¸ Key Differences:

| Feature     | Method Overloading       | Method Overriding          |
| ----------- | ------------------------ | -------------------------- |
| Type        | Compile-Time             | Runtime                    |
| Class       | Same class               | Subclass & Superclass      |
| Parameters  | Must be different        | Must be same               |
| Return type | Can be same or different | Must be same or compatible |
| Keyword     | Not needed               | Use `@Override` annotation |

---

## ğŸ”¸Summary in One Line:

> Polymorphism allows the **same method or object** to behave **differently** in **different situations**.

---

Great! Let's now go **deeper into the types of Polymorphism** in Java â€” in a **very easy and beginner-friendly way**, with examples and differences.

---

## ğŸ”· What Are the Types of Polymorphism?

Java supports **two main types** of polymorphism:

| Polymorphism Type | Also Known As            | Happens When?   |
| ----------------- | ------------------------ | --------------- |
| **Compile-time**  | **Static Polymorphism**  | At compile time |
| **Runtime**       | **Dynamic Polymorphism** | At runtime      |

---

## âœ… 1. Compile-Time Polymorphism (Static)

**Achieved by:**
ğŸ‘‰ **Method Overloading**

### ğŸ”¸ What is it?

Same method name in the **same class**, but with **different parameters** (type, number, or order).

### ğŸ”¸ Example:

```java
class Calculator {
    void add(int a, int b) {
        System.out.println("Sum: " + (a + b));
    }

    void add(double a, double b) {
        System.out.println("Sum: " + (a + b));
    }

    void add(int a, int b, int c) {
        System.out.println("Sum: " + (a + b + c));
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        c.add(5, 10);          // Calls 2-int method
        c.add(2.5, 3.5);       // Calls 2-double method
        c.add(1, 2, 3);        // Calls 3-int method
    }
}
```

### ğŸ”¸ Output:

```
Sum: 15
Sum: 6.0
Sum: 6
```

### ğŸ”¸ Why "Compile-Time"?

Because the Java compiler decides **which method to call** during **compilation**.

---

## âœ… 2. Runtime Polymorphism (Dynamic)

**Achieved by:**
ğŸ‘‰ **Method Overriding**

### ğŸ”¸ What is it?

Same method name and parameters, but in **parent and child classes**. The child class gives its **own version** of the method.

### ğŸ”¸ Example:

```java
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Cat();  // Reference is of parent, object is of child
        a.sound();             // Calls Cat's version
    }
}
```

### ğŸ”¸ Output:

```
Cat meows
```

### ğŸ”¸ Why "Runtime"?

Because the **actual method** is decided **during execution** (runtime), depending on the object.

---

## âœ… Difference Table

| Feature               | Compile-Time Polymorphism | Runtime Polymorphism |
| --------------------- | ------------------------- | -------------------- |
| Other Name            | Static                    | Dynamic              |
| Achieved by           | Method Overloading        | Method Overriding    |
| When Decision is Made | At compile time           | At runtime           |
| Involves Inheritance? | âŒ Not necessary           | âœ… Yes                |
| Flexibility           | Less flexible             | More flexible        |
| Method Signature      | Must be different         | Must be same         |

---

## ğŸ”¶ Bonus: Other Forms (Advanced)

| Type                        | Description                            |
| --------------------------- | -------------------------------------- |
| **Operator Overloading**    | Not supported in Java (unlike C++)     |
| **Subtype Polymorphism**    | Achieved via inheritance or interfaces |
| **Parametric Polymorphism** | Using generics (`List<T>`)             |

---

## âœ… Final Thought:

> ğŸ¯ **Polymorphism = One interface, many implementations**

It makes Java **flexible, reusable**, and **extensible**.


Let's understand **Static Polymorphism** (also called **Compile-Time Polymorphism**) in Java in **simple terms** with examples, use cases, and how it's different from dynamic polymorphism.

---

## ğŸ”· What is Static Polymorphism?

> âœ… **Static Polymorphism** allows **multiple methods with the same name** to exist in the **same class**, but with **different parameters**.

ğŸ‘‰ This is also known as **Method Overloading**.

---

## ğŸ”¸ Why "Static"?

Because the method to be called is **decided by the compiler at compile time** â€” not during program execution.

---

## âœ… Real-World Analogy

Imagine a **Calculator** app:

* If you enter **2 + 3**, it adds two integers.
* If you enter **2.5 + 3.8**, it adds two decimals.
* If you enter **2 + 3 + 4**, it adds three numbers.

ğŸ§  The **same operation name** â€” `add` â€” behaves **differently** depending on inputs.

---

## âœ… Example in Java

```java
class Calculator {

    // method 1 - two integers
    void add(int a, int b) {
        System.out.println("Sum: " + (a + b));
    }

    // method 2 - three integers
    void add(int a, int b, int c) {
        System.out.println("Sum: " + (a + b + c));
    }

    // method 3 - two doubles
    void add(double a, double b) {
        System.out.println("Sum: " + (a + b));
    }
}
```

### ğŸ”¸ Calling it:

```java
public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        calc.add(10, 20);           // Calls method 1
        calc.add(5, 15, 25);        // Calls method 2
        calc.add(3.5, 2.5);         // Calls method 3
    }
}
```

### ğŸ”¸ Output:

```
Sum: 30
Sum: 45
Sum: 6.0
```

---

## âœ… Rules for Method Overloading (Static Polymorphism)

* Same method name
* Must differ in:

  * Number of parameters **OR**
  * Type of parameters **OR**
  * Order of parameters

âœ… **Return type alone** is **not enough** to overload a method.

---

## âœ… Where is Static Polymorphism Used?

* Utility classes like `Math`, `Arrays`
* Constructors with different arguments
* Logging, formatting, conversion functions
* Overloaded `main()` for testing

---

## âŒ What Itâ€™s *Not*:

* It does **not depend on inheritance**
* It is **not dynamic** â€” method choice is fixed before running

---

## âœ… Summary Table

| Feature               | Static Polymorphism                              |
| --------------------- | ------------------------------------------------ |
| Also called as        | Method Overloading                               |
| Occurs at             | Compile-time                                     |
| Involves inheritance? | No                                               |
| Method signature      | Must be different                                |
| Flexibility           | Less (compared to dynamic)                       |
| Example               | `add(int a, int b)` vs `add(double a, double b)` |

---

Letâ€™s now focus completely on **Overloading** in Java â€“ explained in **very simple English** with **theory, real-world analogy, Java examples, rules**, and **common mistakes**.

---

## ğŸ”· What is Method Overloading?

> **Method Overloading** means **having multiple methods with the same name**, but with **different parameters** in the **same class**.

âœ… It is an example of **Compile-Time Polymorphism** (Static Polymorphism).

---

## ğŸ§  Real-Life Example

Think of a â€œ**Printer**â€ function in a program:

* If you pass a **text**, it prints the text.
* If you pass a **PDF**, it prints the PDF.
* If you pass an **image**, it prints the image.

â¡ï¸ The **function name is the same** (`print()`), but it works differently depending on what you pass â€” this is **overloading**.

---

## âœ… Syntax in Java:

```java
class Printer {

    void print(String message) {
        System.out.println("Printing text: " + message);
    }

    void print(int number) {
        System.out.println("Printing number: " + number);
    }

    void print(String message, int copies) {
        System.out.println("Printing '" + message + "' " + copies + " times.");
    }
}
```

### ğŸ”¸ Main Method to Run:

```java
public class Main {
    public static void main(String[] args) {
        Printer p = new Printer();
        p.print("Hello");
        p.print(123);
        p.print("Hi", 3);
    }
}
```

### ğŸ”¸ Output:

```
Printing text: Hello  
Printing number: 123  
Printing 'Hi' 3 times.  
```

---

## âœ… Rules for Method Overloading

| Allowed Differences      | Explanation                                  |
| ------------------------ | -------------------------------------------- |
| âœ… Number of arguments    | `print(String)` vs `print(String, int)`      |
| âœ… Data type of arguments | `print(int)` vs `print(double)`              |
| âœ… Order of arguments     | `print(String, int)` vs `print(int, String)` |

â›” **Return type alone CANNOT be used to overload**:

```java
// âŒ This is invalid
void print(int a) {}
int print(int a) {}  // âŒ Compiler error: Duplicate method
```

---

## ğŸ”¶ Constructor Overloading

You can also overload **constructors**:

```java
class Student {
    Student(String name) {
        System.out.println("Student: " + name);
    }

    Student(String name, int age) {
        System.out.println("Student: " + name + ", Age: " + age);
    }
}
```

---

## âœ… Why Use Overloading?

* Clean and readable code
* Same method name = easier to remember
* Flexibility to use methods in different ways

---

## âœ… Summary

| Feature                   | Method Overloading          |
| ------------------------- | --------------------------- |
| Type of Polymorphism      | Compile-Time (Static)       |
| Same method name?         | âœ… Yes                       |
| Different parameter list? | âœ… Yes                       |
| Same return type?         | Not required                |
| Inheritance involved?     | âŒ No                        |
| Runtime decision?         | âŒ No, compile-time decision |

---

Great question! ğŸ‘
Let's break it down very **simply**:

---

## ğŸ”· How does Java determine **which method** to run?

When you use **method overloading**, Java chooses **which version** of the method to call based on:

### âœ… 1. **Number of arguments**

### âœ… 2. **Type of arguments**

### âœ… 3. **Order of arguments**

This process happens at **compile-time** (that's why it's called **compile-time polymorphism**).

---

### ğŸ”¶ Example:

```java
class Calculator {
    void add(int a, int b) {
        System.out.println("Adding integers: " + (a + b));
    }

    void add(double a, double b) {
        System.out.println("Adding doubles: " + (a + b));
    }

    void add(int a, int b, int c) {
        System.out.println("Adding three integers: " + (a + b + c));
    }
}
```

### ğŸ”¸ Main Method:

```java
public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        calc.add(10, 20);         // Matches: add(int, int)
        calc.add(2.5, 3.5);       // Matches: add(double, double)
        calc.add(1, 2, 3);        // Matches: add(int, int, int)
    }
}
```

---

## âœ… Java's **Method Selection Rules**

### ğŸ”¹ Step-by-step what Java does:

1. **Match the method name**
2. **Match the number of arguments**
3. **Match the exact data types**
4. If not exact, try **automatic type promotion**
5. If still confused â€” Java gives **compile-time error**

---

### ğŸ”¸ Type Promotion Example:

```java
void print(double a) {
    System.out.println("double: " + a);
}

print(5); // int â†’ double (automatic promotion)
```

But if both `print(int)` and `print(double)` exist, it picks the **exact match** first.

---

## âš ï¸ What if there's no perfect match?

Java uses **automatic type conversion** (called *type promotion*):

* `byte â†’ short â†’ int â†’ long â†’ float â†’ double`
* `char â†’ int`

Example:

```java
void show(float x) {
    System.out.println("float: " + x);
}
show(10);  // int is promoted to float
```

---

## âŒ What if multiple matches?

If Java is confused between multiple matches (ambiguous), it throws **compile-time error**.

```java
void show(int a, float b) {}
void show(float a, int b) {}

// show(10, 20); âŒ Ambiguous: both match partially
```

---

## âœ… Final Summary

| Step   | What Java Checks                        |
| ------ | --------------------------------------- |
| Step 1 | Method name matches                     |
| Step 2 | Number of arguments                     |
| Step 3 | Exact type match                        |
| Step 4 | If no match, try automatic conversion   |
| Step 5 | If multiple fits â†’ Compilation error âš ï¸ |

---

Great! Let's dive into the **`final` keyword in Java** â€” explained in very simple language with clear **theory, real-life examples, syntax**, and **common uses**.

---

## ğŸ”· What is `final` in Java?

The `final` keyword is used to **restrict** or **prevent changes**.

It can be applied to:

1. **Variables**
2. **Methods**
3. **Classes**

---

## ğŸ”¹ 1. `final` Variable (Constant)

When you declare a variable as `final`, its **value cannot be changed** after initialization.

### âœ… Syntax:

```java
final int AGE = 18;
AGE = 20; // âŒ Error: Cannot assign a value to final variable
```

### ğŸ§  Real-Life Example:

Like your **Aadhar number** â€“ it never changes. So it's **final**.

---

## ğŸ”¹ 2. `final` Method

When a method is declared as `final`, it **cannot be overridden** by subclasses.

### âœ… Syntax:

```java
class Animal {
    final void sound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    // void sound() { âŒ Error: Cannot override final method
    //     System.out.println("Bark");
    // }
}
```

### ğŸ§  Real-Life Example:

Like a **rule set by your school principal** â€“ students (subclasses) cannot change it.

---

## ğŸ”¹ 3. `final` Class

When a class is declared as `final`, **no other class can extend it** (i.e., no inheritance).

### âœ… Syntax:

```java
final class Vehicle {
    void move() {
        System.out.println("Vehicle is moving");
    }
}

// class Car extends Vehicle { âŒ Error: Cannot inherit from final class
// }
```

### ğŸ§  Real-Life Example:

Like a **sealed envelope** â€“ you can't add anything to it once it's sealed.

---

## ğŸ“Œ Summary Table:

| Use on   | Meaning                            | Can Be Modified Later? |
| -------- | ---------------------------------- | ---------------------- |
| Variable | Makes the variable a constant      | âŒ No                   |
| Method   | Prevents method overriding         | âŒ No                   |
| Class    | Prevents inheritance (subclassing) | âŒ No                   |

---

## âš ï¸ Extra Tip: Final + Static

You can also use both:

```java
static final double PI = 3.14159;
```

This is a **common way to define constants** in Java.

---

Great question! Let's clear it up with **simple language**, **code examples**, and **real-life analogy**.

---

## ğŸ”· Can we override static methods in Java?

> âŒ **NO**, **static methods cannot be overridden** in Java like instance methods.

---

## ğŸ”¸ Why?

Because **static methods belong to the class**, not to instances (objects).
So when you define a static method in a subclass with the same name, it's **method hiding**, not overriding.

---

## âœ… Real Example to Understand:

```java
class Parent {
    static void show() {
        System.out.println("Static method in Parent");
    }
}

class Child extends Parent {
    static void show() {
        System.out.println("Static method in Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.show();  // Output: Static method in Parent
    }
}
```

---

## ğŸ” Output:

```
Static method in Parent
```

Even though the object is of `Child`, Java **does not override static methods** â€” it uses the method based on **reference type**, not object type.

---

## ğŸ§  Real-Life Analogy:

* A **TV remote** (class) has a **power button** (static method).
* No matter how many TVs (objects) you have, the **remoteâ€™s power button behavior doesnâ€™t change**. It belongs to the **remote model**, not the TV unit.

---

## âœ… Summary

| Feature         | Can be Overridden?      | Notes                                |
| --------------- | ----------------------- | ------------------------------------ |
| Instance Method | âœ… Yes                   | Based on runtime object              |
| Static Method   | âŒ No                    | Can be hidden, but not overridden    |
| Called via      | Class name or reference | Executes based on **reference type** |

---

## âœ… Extra Tip:

You **can hide** static methods (method hiding), but Java won't consider it as overriding.

---

No worries! Let me explain **step by step** with a **very easy real-world example** and code.
Weâ€™ll compare:

* âœ… **Overriding** (for normal methods)
* âŒ **Hiding** (for static methods)

---

## ğŸ¯ Letâ€™s start with a real-world comparison:

### ğŸ§  Normal method (Overriding):

Imagine you have a **Parent class** and a **Child class**.
Both have a method called `sayHello()`.

Now, if you create a `Child` object and call `sayHello()`, Java uses the **Child's version** of the method. This is **Overriding**.

---

### ğŸ”’ Static method (Hiding):

Now letâ€™s say both classes have a **static method** called `sayHelloStatic()`.

Even if you create a `Child` object, **Java uses the method from the Parent** (not Child) if the reference is of Parent type.

This is **method hiding**, **not overriding**.

---

## âœ… Code Example to Understand Easily

```java
class Parent {
    void normalHello() {
        System.out.println("Hello from Parent (normal method)");
    }

    static void staticHello() {
        System.out.println("Hello from Parent (static method)");
    }
}

class Child extends Parent {
    void normalHello() {
        System.out.println("Hello from Child (normal method)");
    }

    static void staticHello() {
        System.out.println("Hello from Child (static method)");
    }
}
```

### ğŸ” Main Code:

```java
public class Main {
    public static void main(String[] args) {
        Parent obj = new Child(); // Parent reference, Child object

        obj.normalHello(); // Output? ğŸ‘‰ "Hello from Child"
        obj.staticHello(); // Output? ğŸ‘‰ "Hello from Parent"
    }
}
```

---

## ğŸ§¾ Output:

```
Hello from Child (normal method)
Hello from Parent (static method)
```

---

## â“ Why different behavior?

* `normalHello()` is an **instance method** â†’ Java looks at the **object type** (Child) â†’ So **overridden**
* `staticHello()` is a **static method** â†’ Java looks at the **reference type** (Parent) â†’ So **hidden**, not overridden

---

## âœ… Final Summary Table:

| Method Type   | Can Override? | Output Based on          | Behavior Name |
| ------------- | ------------- | ------------------------ | ------------- |
| Normal Method | âœ… Yes         | Object (`new Child()`)   | Overriding    |
| Static Method | âŒ No          | Reference (`Parent obj`) | Method Hiding |

---

Great! Letâ€™s break down **Encapsulation** in Java in **very simple terms**, with:

* âœ… Definition
* ğŸ§  Real-life Example
* ğŸ‘¨â€ğŸ’» Java Code
* ğŸ“Œ Key Benefits
* ğŸ¤” Why it matters in OOP

---

## ğŸ”· What is Encapsulation?

**Encapsulation** means **binding data (variables)** and **code (methods)** together as one unit and **restricting direct access** to the data.

> You **hide the internal details** and only show what is necessary.

---

## ğŸ§  Real-Life Example

Think of a **capsule** (medicine):

* You donâ€™t know whatâ€™s inside (data)
* But you know how to **use** it (method: take it with water)
* You **cannot directly access** what's inside â€“ it's **protected**

---

## ğŸ‘¨â€ğŸ’» Java Example of Encapsulation

```java
class Student {
    // ğŸ” Private data - cannot be accessed directly
    private String name;
    private int age;

    // âœ… Public methods to access private data (Getters and Setters)
    public void setName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }

    public void setAge(int a) {
        if (a > 0) {
            age = a;
        }
    }

    public int getAge() {
        return age;
    }
}
```

### ğŸ” How to use it:

```java
public class Main {
    public static void main(String[] args) {
        Student s = new Student();

        s.setName("Aniket");
        s.setAge(20);

        System.out.println("Name: " + s.getName());
        System.out.println("Age: " + s.getAge());
    }
}
```

---

## ğŸ§© Key Features of Encapsulation

| Feature              | Description                            |
| -------------------- | -------------------------------------- |
| ğŸ” Private Variables | Data is hidden from outside classes    |
| ğŸ› ï¸ Getters/Setters  | Access/modify data in a controlled way |
| ğŸš« No Direct Access  | No access like `s.name = "abc"` âŒ      |
| âœ… Easy Maintenance   | Internal code can change safely        |

---

## ğŸ“Œ Benefits of Encapsulation

1. âœ… Protects data from unwanted access
2. âœ… Improves **security** of the program
3. âœ… Makes code **easier to maintain or change**
4. âœ… Allows validation logic in setters (e.g., age > 0)

---

## ğŸ’¬ Simple Summary

> **Encapsulation = Data Hiding + Controlled Access**

---


No problem! Let's make **Encapsulation** super easy to understand with a **real-world explanation**, **very simple code**, and a complete file named `Main.java`.

---

## ğŸ§  Imagine this:

You have a **Student**. You want to store their **name** and **age**.

But you donâ€™t want *anyone* to be able to randomly change their age to -10. Thatâ€™s wrong!

So, you **hide** the name and age inside the class (make them private) and only allow safe access through **getters** and **setters**.

This is called **Encapsulation**.

---

## âœ… Complete Code â€” `Main.java`

```java
// File: Main.java

class Student {
    // ğŸ” Private = hidden from outside the class
    private String name;
    private int age;

    // ğŸ› ï¸ Setter = to set the value (write)
    public void setName(String n) {
        name = n;
    }

    public void setAge(int a) {
        if (a > 0) {  // age must be positive
            age = a;
        } else {
            System.out.println("Age must be greater than 0");
        }
    }

    // ğŸ“– Getter = to get the value (read)
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class Main {
    public static void main(String[] args) {
        Student s = new Student(); // ğŸ§’ Create object

        // Set values safely using setter methods
        s.setName("Aniket");
        s.setAge(20);

        // Get values using getter methods
        System.out.println("Name: " + s.getName());
        System.out.println("Age: " + s.getAge());

        // Try setting wrong value
        s.setAge(-5); // âŒ Wonâ€™t allow
    }
}
```

---

## ğŸ§¾ Output:

```
Name: Aniket
Age: 20
Age must be greater than 0
```

---

## ğŸ’¡ Why This Is Called Encapsulation:

| Concept           | What We Did                           |
| ----------------- | ------------------------------------- |
| Private Variables | `name` and `age` are hidden (private) |
| Controlled Access | Used `setName()`, `setAge()`          |
| Validation        | Checked if age > 0 before setting     |
| Secure & Clean    | Others can't misuse your class        |

---

## ğŸ§  Real-Life Example:

You go to an ATM:

* You **can't touch** the cash inside the machine (private)
* You press buttons (public methods) to **withdraw** or **check balance**
* The ATM **validates** your PIN before allowing access

This is **Encapsulation**.

---

